#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

# 解一、动态规划

 第 1 步：定义状态：

首先考虑题目问什么，就把什么定义成状态 

 `dp[i]` 表示以 `nums[i]` 结尾的「上升子序列」的长度。 

 注意： `nums[i]` 必须被选取，且必须是这个子序列的最后一个元素。 

 第 2 步：考虑状态转移方程：

- 遍历到`nums[i]`时，需要把下标 i 之前的所有的数都看一遍；
- 只要`nums[i]`严格大于在它位置之前的某个数，那么 `nums[i]` 就可以接在这个数后面形成一个更长的上升子序列；
- 因此，`dp[i]` 就等于下标 `i` 之前严格小于`nums[i]` 的状态值的最大者`+1`。

 **转移方程：** `dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)`。 

 第 3 步：考虑初始化

- `dp[i] = 1` ： 每个元素都至少可以单独成为子序列 

第 4 步：考虑输出

- 状态数组 `dp` 的最大值，即全局最长上升子序列长度 

第 5 步：考虑状态压缩。

- 遍历到一个新数的时候，之前所有的状态值都得保留，因此无法压缩。

# 解二、贪心 + 二分查找